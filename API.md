# LUR-E API

This is a consolidated, human-friendly overview of the public API exported from `src/index.ts`. For the full, generated reference, see the markdown files under `./docs/`.

## Imports

```ts
import {
  // Core
  bindBeh, bindCtrl, bindHandler, bindWith, bindForms,
  $observeInput, $observeAttribute,
  // Refs
  makeRef, attrRef, valueRef, valueAsNumberRef, localStorageRef,
  sizeRef, checkedRef, scrollRef, visibleRef, matchMediaRef, hashTargetRef, orientRef, makeWeakRef,
  // Node
  E, M, Q, createElement, H,
  // Extensions (selected)
  bindDraggable, grabForDrag, agWrapEvent,
} from "fest/lure";
```

## Quick Start

```ts
// Create an element
const el = E("div", {
  attributes: { id: "app" },
  classList: new Set(["box"]),
  style: { padding: "8px" },
}, [
  "Hello",
]);

document.body.append(el as Node);
```

## Core

- `bindBeh(element, store, behavior)`: Invoke `behavior` on store changes.
- `bindCtrl(element, ctrlCb)`: Wire common input/change/click listeners.
- `bindHandler(element, value, prop, handler, set?, withObserver?)`: Generic bridge for refs → DOM.
- `bindWith(el, prop, value, handler, set?, withObserver?)`: Apply once and subscribe.
- `bindForms(fields?, wrapper?, state?)`: Two-way bind inputs within a container to a reactive `state`.
- `$observeInput(element, ref?, prop = "value")`: Sync input property to ref.
- `$observeAttribute(el, ref?, prop)`: Sync attribute to ref.

## Refs

Create reactive references, often linked to DOM state:

- `makeRef(host?, type?, link?, ...args)`
- `attrRef(host, name)`, `valueRef(host, name)`, `valueAsNumberRef(host, name)`
- `localStorageRef(key)`, `sizeRef(host, prop?)`, `checkedRef(host)`, `scrollRef(host, prop?)`, `visibleRef(host)`
- `matchMediaRef(query)`, `hashTargetRef()`, `orientRef(host)`
- `makeWeakRef(initial?, behavior?)`

## Node API

### E: Element factory with bindings

```ts
const out = E("button", {
  attributes: { title: "Click me" },
  properties: { disabled: false },
  on: { click: (e) => console.log("clicked", e) },
}, ["OK"]);
```

### JSX factory

```tsx
// Use with JSX if configured (jsxFactory: createElement)
const v = createElement("div", { className: "c" }, ["hello"]);
```

### Q: Query wrapper

```ts
const box = Q("#app");
box.attr.id = "app2"; // example of reactive wrapper operations
```

### M: Reactive mapping

`M(observable, mapper)` maps a reactive array/set into DOM. Returns a reactive fragment-like node.

```ts
import { makeReactive } from "fest/object";

const rxItems = makeReactive(["A", "B", "C"]);
const list = H`<ul>${M(rxItems, (x) => H`<li>${x}</li>`)}</ul>`;

// later
rxItems.push("D"); // DOM updates
```

## H and HTML Templates

`H` supports both raw HTML strings and tagged template strings.

- Raw string starting/ending with `<`/`>` → parsed into `Node`/`DocumentFragment`.
- Plain string → `Text` node.
- Function → invoked and processed recursively.
- Tagged template → interpolates values into content/attributes/events/props.

Attribute/prop/event/ref prefixes inside tagged templates:
- `attr:*` → HTML attribute
- `prop:*` → DOM property
- `on:*` or `@*` → event listener
- `ref` or `ref:*` → assigns element to ref(s)

Examples:

```ts
// Raw string → Node
const el = H("<div class=box>hello</div>");

// Tagged template → content interpolation
const name = "World";
const title = H`<h1 class="title">Hello, ${name}!</h1>`;

// Dynamic tag: supports tag#id.class1.class2
const tag = "button.primary";
const btn = H`<${tag}>Click</${tag}>`;

// Attributes/props/events/refs
const ref = { value: null as HTMLElement | null };
const click = (e: Event) => console.log("clicked", e);
const button = H`<button attr:title=${"Click"} prop:disabled=${false} on:click=${click} ref=${ref}>OK</button>`;
```

Static vs Reactive lists in `H` content:

```ts
// Static (non-reactive) mapping in template content
const items = ["A", "B", "C"];
const listStatic = H`<ul>${items.map(x => H`<li>${x}</li>`)}</ul>`;

// Reactive list: use M(...)
import { makeReactive } from "fest/object";
const rxItems = makeReactive(["A", "B", "C"]);
const listReactive = H`<ul>${M(rxItems, (x) => H`<li>${x}</li>`)}</ul>`;
```

Multiple top-level nodes produce a `DocumentFragment`:

```ts
const frag = H`<div>one</div><div>two</div>`; // DocumentFragment
```

## Extensions (selection)

Pointer helpers and drag handling:

```ts
import { bindDraggable, grabForDrag } from "fest/lure";

const target = H`<div class="draggable" />` as HTMLElement;
bindDraggable(target, () => console.log("drag end"));
```

## Documentation

- Full markdown API reference is generated into `./docs/` by:

```bash
npm run docs:md
```

- HTML documentation can be generated by:

```bash
npm run docs
```
