import { observe, affected } from "fest/object";
import { addEvent } from "fest/dom";
import { isPrimitive } from "fest/core";
import { getIgnoreNextPopState, setIgnoreNextPopState } from "./BackNavigation";
//
const STATE_KEY = "rs-nav-ctx";
const STACK_KEY = "rs-nav-stack";
// Global reactive state for history
export const historyState = observe({
    index: 0,
    length: 0,
    action: "MANUAL",
    view: "",
    canBack: false,
    canForward: false,
    entries: []
});
// Helper to get current state safely
const getCurrentState = () => {
    try {
        return history.state?.[STATE_KEY] || historyState?.entries?.[historyState?.index] || {};
    }
    catch (e) {
        return {};
    }
};
// Helper to save/load stack
const saveStack = () => {
    try {
        sessionStorage.setItem(STACK_KEY, JSON.stringify(historyState?.entries));
    }
    catch (e) { }
};
const loadStack = () => {
    try {
        const stored = sessionStorage.getItem(STACK_KEY);
        return stored ? JSON.parse(stored) : [];
    }
    catch (e) {
        return [];
    }
};
// Helper to merge state
const mergeState = (newState, existingData) => {
    try {
        const current = existingData !== undefined ? existingData : (history?.state || {});
        if (isPrimitive(current) && current !== null)
            return { value: current, [STATE_KEY]: newState };
        if (current === null)
            return { [STATE_KEY]: newState };
        return { ...current, [STATE_KEY]: newState };
    }
    catch (e) {
        return { [STATE_KEY]: newState };
    }
};
//
let initialized = false;
// Patch pushState and replaceState
export const originalPush = typeof history != "undefined" ? history.pushState.bind(history) : undefined;
export const originalReplace = typeof history != "undefined" ? history.replaceState.bind(history) : undefined;
export const originalGo = typeof history != "undefined" ? history.go.bind(history) : undefined;
export const originalForward = typeof history != "undefined" ? history.forward.bind(history) : undefined;
export const originalBack = typeof history != "undefined" ? history.back.bind(history) : undefined;
// Initialize history tracking
export const initHistory = (initialView = "") => {
    if (initialized)
        return;
    initialized = true;
    //
    const current = getCurrentState();
    const view = initialView || location.hash || "#";
    // Load or init stack
    let stack = loadStack();
    const idx = current.index || 0;
    // Validate stack against current state
    if (stack && (stack?.length === 0 || idx >= stack?.length) /* || stack[idx]?.view !== (current.view || view) */) {
        // If stack is invalid or empty, we try to reconstruct or reset
        // For a new session, we might want to start fresh or trust the stack if it seems plausible
        // But if history.state has an index that doesn't match stack, trust history.state (browser truth)
        if (stack.length <= idx) {
            // Stack missing or too short. Reset/Expand
            stack[idx] = {
                index: idx,
                depth: history.length,
                action: current?.action || "REPLACE",
                view: view,
                timestamp: Date.now()
            };
        }
    }
    historyState.entries = stack;
    // Set initial state if needed
    if (!current.timestamp) {
        const state = {
            index: idx,
            depth: history.length,
            action: "REPLACE",
            view: view,
            timestamp: Date.now()
        };
        history?.replaceState?.(mergeState(state), "", location.hash);
        // Update stack
        if (historyState?.entries) {
            historyState.entries[idx] = state;
        }
        saveStack();
    }
    else {
        // Sync reactive state with existing history state
        historyState.index = current.index || 0;
        historyState.view = current.view || view;
        // Ensure stack matches current
        if (!historyState?.entries?.[historyState?.index]) {
            historyState.entries[historyState.index] = current;
            saveStack();
        }
    }
    updateReactiveState(getCurrentState()?.action || "REPLACE", view);
    //
    history.go = (delta = 0) => {
        const currentState = getCurrentState();
        currentState.index = Math.max(0, Math.min(historyState.length, (currentState.index || 0) + delta));
        const existsState = historyState.entries[currentState.index];
        Object.assign(currentState, existsState || {});
        //
        setIgnoreNextPopState(true);
        const result = originalGo?.(delta);
        setTimeout(() => { setIgnoreNextPopState(false); }, 0);
        //
        updateReactiveState((currentState?.action || "POP") || (delta > 0 ? "FORWARD" : "BACK"), currentState?.view);
        return result;
    };
    history.back = () => { return history.go(-1); };
    history.forward = () => { return history.go(1); };
    history.pushState = (data, unused, url) => {
        const currentState = getCurrentState();
        const nextIndex = (currentState.index || 0) + 1;
        const newState = {
            index: nextIndex,
            depth: history.length + 1,
            action: "PUSH",
            view: url ? String(url) : (currentState.view || ""),
            timestamp: Date.now()
        };
        const result = originalPush?.(mergeState(newState, data), unused, url);
        // Update stack: wipe forward history
        historyState.entries = historyState?.entries?.slice?.(0, nextIndex);
        historyState.entries?.push?.(newState);
        saveStack();
        updateReactiveState("PUSH", newState.view);
        return result;
    };
    //
    history.replaceState = (data, unused, url) => {
        const currentState = getCurrentState();
        const index = currentState?.index || 0;
        //
        const newState = {
            ...currentState,
            index: index,
            depth: history.length,
            action: "REPLACE",
            view: url ? String(url) : (currentState?.view || ""),
            timestamp: Date.now()
        };
        //
        const result = originalReplace?.(mergeState(newState, data), unused, url);
        // Update stack: replace current
        if (historyState?.entries) {
            historyState.entries[index] = newState;
            historyState.entries[historyState.index].view = url ? String(url) : (currentState?.view || "");
        }
        //
        saveStack();
        updateReactiveState("REPLACE", newState.view);
        return result;
    };
    // Listen for popstate
    addEvent(window, "popstate", (ev) => {
        const state = ev.state?.[STATE_KEY];
        const currentIndex = historyState.index ?? 0;
        if (!state) {
            // Likely a hash change or external navigation
            // We treat it as a PUSH for now if we can't determine otherwise
            // But if we have entries, we might check if hash matches?
            // For now, keep existing logic
            const newState = {
                index: currentIndex + 1,
                depth: history.length,
                action: "PUSH",
                view: location.hash || "#",
                timestamp: Date.now()
            };
            // Inject state but preserve any existing state if present (unlikely if ev.state is null)
            history.replaceState(mergeState(newState, ev.state), "", location.hash);
            // Update stack
            historyState.entries = historyState?.entries?.slice?.(0, newState.index);
            historyState?.entries?.push?.(newState);
            saveStack();
            updateReactiveState("PUSH", newState.view);
            return;
        }
        else {
            const newIndex = state?.index ?? 0;
            let action = "POP";
            if (newIndex < currentIndex) {
                action = "BACK";
            }
            else if (newIndex > currentIndex) {
                action = "FORWARD";
            }
            updateReactiveState(action, state?.view || location.hash);
        }
    });
    // Listen for hashchange as fallback/augment
    // This ensures we catch changes that might bypass popstate in some scenarios
    // or when manual location.hash assignment occurs without history API
    addEvent(window, "hashchange", (ev) => {
        if (getIgnoreNextPopState())
            return;
        const currentHash = location.hash || "#";
        // Only update if historyState hasn't caught up yet (deduplication with popstate)
        if (historyState.view !== currentHash) {
            // prevent hatching popstate event
            updateReactiveState("PUSH", currentHash);
        }
    });
};
//
const updateReactiveState = (action, view) => {
    const current = getCurrentState();
    historyState.index = current.index || 0;
    historyState.length = history.length;
    historyState.action = action || "POP";
    historyState.view = view || current.view || location.hash;
    historyState.canBack = historyState.index > 0;
};
// Navigation helpers
export const navigate = (view, replace = false) => {
    const hash = view.startsWith("#") ? view : `#${view}`;
    // Optimization: if replacing, check if we are just going back to previous view
    if (replace && historyState?.index > 0) {
        const prev = historyState?.entries?.[historyState?.index - 1];
        if (prev && prev.view === hash) {
            // prevent hatching popstate event
            history.back();
            return;
        }
    }
    // when doing navigation, stop hatching popstate event
    if (replace) {
        // don't do anything if the current view is the same as the new view
        if (historyState?.entries?.[historyState.index]?.view !== hash || historyState?.entries?.[historyState.index]?.view) {
            history?.replaceState?.(null, "", hash);
        }
    }
    else {
        history?.pushState?.(null, "", hash);
    }
};
//
export const historyViewRef = (initialValue = `#${location.hash?.replace?.(/^#/, "") || "home"}`, options = {}) => {
    const internal = observe({ value: initialValue });
    // Prevent circular updates between history and internal value
    let isUpdatingFromHistory = false;
    let isUpdatingFromInternal = false;
    // Sync from history to ref
    // The historyState acts as a bridge:
    // 1. User Action (Back/Forward) -> Window 'popstate' -> initHistory listener -> historyState -> This Subscription
    // 2. User Action (Hash Change) -> Window 'hashchange' -> initHistory listener -> historyState -> This Subscription
    affected([historyState, "view"], (view) => {
        if (isUpdatingFromInternal)
            return; // Prevent circular update
        if (options.ignoreBack && historyState.action === "BACK") {
            return;
        }
        let nextValue = view;
        if (options.withoutHashPrefix) {
            nextValue = view.replace(/^#/, "");
        }
        if (internal.value !== nextValue) {
            isUpdatingFromHistory = true;
            internal.value = nextValue;
            isUpdatingFromHistory = false;
        }
    });
    // Sync from ref to history
    // Application Action (Programmatic) -> ref.value change -> This Subscription -> navigate() -> pushState() -> historyState
    affected([internal, "value"], (val) => {
        if (isUpdatingFromHistory)
            return; // Prevent circular update
        let viewToNavigate = val;
        if (options.withoutHashPrefix && !val.startsWith("#")) {
            viewToNavigate = `#${val}`;
        }
        if (historyState.view !== viewToNavigate) {
            isUpdatingFromInternal = true;
            // This is a programmatic change, so we PUSH
            navigate(viewToNavigate);
            isUpdatingFromInternal = false;
        }
    });
    // Proxy to return the ref but with special behavior if needed
    return internal;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGlzdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkhpc3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE9BQU8sRUFBVyxRQUFRLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDekQsT0FBTyxFQUFFLFFBQVEsRUFBUSxNQUFNLFVBQVUsQ0FBQztBQUMxQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBZWhGLEVBQUU7QUFDRixNQUFNLFNBQVMsR0FBRyxZQUFZLENBQUM7QUFDL0IsTUFBTSxTQUFTLEdBQUcsY0FBYyxDQUFDO0FBYWpDLG9DQUFvQztBQUNwQyxNQUFNLENBQUMsTUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDO0lBQ2hDLEtBQUssRUFBRSxDQUFDO0lBQ1IsTUFBTSxFQUFFLENBQUM7SUFDVCxNQUFNLEVBQUUsUUFBNEI7SUFDcEMsSUFBSSxFQUFFLEVBQUU7SUFDUixPQUFPLEVBQUUsS0FBSztJQUNkLFVBQVUsRUFBRSxLQUFLO0lBQ2pCLE9BQU8sRUFBRSxFQUFxQjtDQUNqQyxDQUErQixDQUFDO0FBRWpDLHFDQUFxQztBQUNyQyxNQUFNLGVBQWUsR0FBRyxHQUEyQixFQUFFO0lBQ2pELElBQUksQ0FBQztRQUNELE9BQU8sT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLFlBQVksRUFBRSxPQUFPLEVBQUUsQ0FBQyxZQUFZLEVBQUUsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzVGLENBQUM7SUFBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1FBQ1QsT0FBTyxFQUFFLENBQUM7SUFDZCxDQUFDO0FBQ0wsQ0FBQyxDQUFDO0FBRUYsNEJBQTRCO0FBQzVCLE1BQU0sU0FBUyxHQUFHLEdBQUcsRUFBRTtJQUNuQixJQUFJLENBQUM7UUFDRCxjQUFjLENBQUMs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QyxJQUFJLEtBQUssY0FBYyxFQUFFLENBQUM7WUFDdkMsc0JBQXNCLEdBQUcsSUFBSSxDQUFDO1lBQzlCLDRDQUE0QztZQUM1QyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDekIsc0JBQXNCLEdBQUcsS0FBSyxDQUFDO1FBQ25DLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUVILDhEQUE4RDtJQUM5RCxPQUFPLFFBQVEsQ0FBQztBQUNwQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBvYnNlcnZlLCBwcm9wUmVmLCBhZmZlY3RlZCB9IGZyb20gXCJmZXN0L29iamVjdFwiO1xuaW1wb3J0IHsgYWRkRXZlbnQsIGhhc2ggfSBmcm9tIFwiZmVzdC9kb21cIjtcbmltcG9ydCB7IGlzUHJpbWl0aXZlIH0gZnJvbSBcImZlc3QvY29yZVwiO1xuaW1wb3J0IHsgZ2V0SWdub3JlTmV4dFBvcFN0YXRlLCBzZXRJZ25vcmVOZXh0UG9wU3RhdGUgfSBmcm9tIFwiLi9CYWNrTmF2aWdhdGlvblwiO1xuXG4vL1xuZXhwb3J0IHR5cGUgTmF2aWdhdGlvbkFjdGlvbiA9IFwiUFVTSFwiIHwgXCJSRVBMQUNFXCIgfCBcIlBPUFwiIHwgXCJCQUNLXCIgfCBcIkZPUldBUkRcIiB8IFwiTUFOVUFMXCI7XG5cbi8vXG5leHBvcnQgaW50ZXJmYWNlIElIaXN0b3J5U3RhdGUge1xuICAgIGluZGV4OiBudW1iZXI7XG4gICAgZGVwdGg6IG51bWJlcjtcbiAgICBhY3Rpb246IE5hdmlnYXRpb25BY3Rpb247XG4gICAgdmlldzogc3RyaW5nO1xuICAgIHRpbWVzdGFtcDogbnVtYmVyO1xuICAgIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuLy9cbmNvbnN0IFNUQVRFX0tFWSA9IFwicnMtbmF2LWN0eFwiO1xuY29uc3QgU1RBQ0tfS0VZID0gXCJycy1uYXYtc3RhY2tcIjtcblxuLy9cbmV4cG9ydCBpbnRlcmZhY2UgSUhpc3RvcnlNYW5hZ2VyIHtcbiAgICBpbmRleDogbnVtYmVyO1xuICAgIGxlbmd0aDogbnVtYmVyO1xuICAgIGFjdGlvbjogTmF2aWdhdGlvbkFjdGlvbjtcbiAgICB2aWV3OiBzdHJpbmc7XG4gICAgY2FuQmFjazogYm9vbGVhbjtcbiAgICBjYW5Gb3J3YXJkOiBib29sZWFuO1xuICAgIGVudHJpZXM6IElIaXN0b3J5U3RhdGVbXTtcbn1cblxuLy8gR2xvYmFsIHJlYWN0aXZlIHN0YXRlIGZvciBoaXN0b3J5XG5leHBvcnQgY29uc3QgaGlzdG9yeVN0YXRlID0gb2JzZXJ2ZSh7XG4gICAgaW5kZXg6IDAsXG4gICAgbGVuZ3RoOiAwLFxuICAgIGFjdGlvbjogXCJNQU5VQUxcIiBhcyBOYXZpZ2F0aW9uQWN0aW9uLFxuICAgIHZpZXc6IFwiXCIsXG4gICAgY2FuQmFjazogZmFsc2UsXG4gICAgY2FuRm9yd2FyZDogZmFsc2UsXG4gICAgZW50cmllczogW10gYXMgSUhpc3RvcnlTdGF0ZVtdXG59KSBhcyB1bmtub3duIGFzIElIaXN0b3J5TWFuYWdlcjtcblxuLy8gSGVscGVyIHRvIGdldCBjdXJyZW50IHN0YXRlIHNhZmVseVxuY29uc3QgZ2V0Q3VycmVudFN0YXRlID0gKCk6IFBhcnRpYWw8SUhpc3RvcnlTdGF0ZT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBoaXN0b3J5LnN0YXRlPy5bU1RBVEVfS0VZXSB8fCBoaXN0b3J5U3RhdGU/LmVudHJpZXM/LltoaXN0b3J5U3RhdGU/LmluZGV4XSB8fCB7fTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59O1xuXG4vLyBIZWxwZXIgdG8gc2F2ZS9sb2FkIHN0YWNrXG5jb25zdCBzYXZlU3RhY2sgPSAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShTVEFDS19LRVksIEpTT04uc3RyaW5naWZ5KGhpc3RvcnlTdGF0ZT8uZW50cmllcykpO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxufTtcblxuY29uc3QgbG9hZFN0YWNrID0gKCk6IElIaXN0b3J5U3RhdGVbXSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShTVEFDS19LRVkpO1xuICAgICAgICByZXR1cm4gc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDogW107XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufTtcblxuLy8gSGVscGVyIHRvIG1lcmdlIHN0YXRlXG5jb25zdCBtZXJnZVN0YXRlID0gKG5ld1N0YXRlOiBhbnksIGV4aXN0aW5nRGF0YT86IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBleGlzdGluZ0RhdGEgIT09IHVuZGVmaW5lZCA/IGV4aXN0aW5nRGF0YSA6IChoaXN0b3J5Py5zdGF0ZSB8fCB7fSk7XG4gICAgICAgIGlmIChpc1ByaW1pdGl2ZShjdXJyZW50KSAmJiBjdXJyZW50ICE9PSBudWxsKSByZXR1cm4geyB2YWx1ZTogY3VycmVudCwgW1NUQVRFX0tFWV06IG5ld1N0YXRlIH07XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSByZXR1cm4geyBbU1RBVEVfS0VZXTogbmV3U3RhdGUgfTtcbiAgICAgICAgcmV0dXJuIHsgLi4uY3VycmVudCwgW1NUQVRFX0tFWV06IG5ld1N0YXRlIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4geyBbU1RBVEVfS0VZXTogbmV3U3RhdGUgfTtcbiAgICB9XG59O1xuXG4vL1xubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vIFBhdGNoIHB1c2hTdGF0ZSBhbmQgcmVwbGFjZVN0YXRlXG5leHBvcnQgY29uc3Qgb3JpZ2luYWxQdXNoID0gdHlwZW9mIGhpc3RvcnkgIT0gXCJ1bmRlZmluZWRcIiA/IGhpc3RvcnkucHVzaFN0YXRlLmJpbmQoaGlzdG9yeSkgOiB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3Qgb3JpZ2luYWxSZXBsYWNlID0gdHlwZW9mIGhpc3RvcnkgIT0gXCJ1bmRlZmluZWRcIiA/IGhpc3RvcnkucmVwbGFjZVN0YXRlLmJpbmQoaGlzdG9yeSkgOiB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3Qgb3JpZ2luYWxHbyA9IHR5cGVvZiBoaXN0b3J5ICE9IFwidW5kZWZpbmVkXCIgPyBoaXN0b3J5LmdvLmJpbmQoaGlzdG9yeSkgOiB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3Qgb3JpZ2luYWxGb3J3YXJkID0gdHlwZW9mIGhpc3RvcnkgIT0gXCJ1bmRlZmluZWRcIiA/IGhpc3RvcnkuZm9yd2FyZC5iaW5kKGhpc3RvcnkpIDogdW5kZWZpbmVkO1xuZXhwb3J0IGNvbnN0IG9yaWdpbmFsQmFjayA9IHR5cGVvZiBoaXN0b3J5ICE9IFwidW5kZWZpbmVkXCIgPyBoaXN0b3J5LmJhY2suYmluZChoaXN0b3J5KSA6IHVuZGVmaW5lZDtcblxuLy8gSW5pdGlhbGl6ZSBoaXN0b3J5IHRyYWNraW5nXG5leHBvcnQgY29uc3QgaW5pdEhpc3RvcnkgPSAoaW5pdGlhbFZpZXc6IHN0cmluZyA9IFwiXCIpID0+IHtcbiAgICBpZiAoaW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICBpbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAvL1xuICAgIGNvbnN0IGN1cnJlbnQgPSBnZXRDdXJyZW50U3RhdGUoKTtcbiAgICBjb25zdCB2aWV3ID0gaW5pdGlhbFZpZXcgfHwgbG9jYXRpb24uaGFzaCB8fCBcIiNcIjtcblxuICAgIC8vIExvYWQgb3IgaW5pdCBzdGFja1xuICAgIGxldCBzdGFjayA9IGxvYWRTdGFjaygpO1xuICAgIGNvbnN0IGlkeCA9IGN1cnJlbnQuaW5kZXggfHwgMDtcblxuICAgIC8vIFZhbGlkYXRlIHN0YWNrIGFnYWluc3QgY3VycmVudCBzdGF0ZVxuICAgIGlmIChzdGFjayAmJiAoc3RhY2s/Lmxlbmd0aCA9PT0gMCB8fCBpZHggPj0gc3RhY2s/Lmxlbmd0aCkgLyogfHwgc3RhY2tbaWR4XT8udmlldyAhPT0gKGN1cnJlbnQudmlldyB8fCB2aWV3KSAqLykge1xuICAgICAgICAvLyBJZiBzdGFjayBpcyBpbnZhbGlkIG9yIGVtcHR5LCB3ZSB0cnkgdG8gcmVjb25zdHJ1Y3Qgb3IgcmVzZXRcbiAgICAgICAgLy8gRm9yIGEgbmV3IHNlc3Npb24sIHdlIG1pZ2h0IHdhbnQgdG8gc3RhcnQgZnJlc2ggb3IgdHJ1c3QgdGhlIHN0YWNrIGlmIGl0IHNlZW1zIHBsYXVzaWJsZVxuICAgICAgICAvLyBCdXQgaWYgaGlzdG9yeS5zdGF0ZSBoYXMgYW4gaW5kZXggdGhhdCBkb2Vzbid0IG1hdGNoIHN0YWNrLCB0cnVzdCBoaXN0b3J5LnN0YXRlIChicm93c2VyIHRydXRoKVxuICAgICAgICBpZiAoc3RhY2subGVuZ3RoIDw9IGlkeCkge1xuICAgICAgICAgICAgLy8gU3RhY2sgbWlzc2luZyBvciB0b28gc2hvcnQuIFJlc2V0L0V4cGFuZFxuICAgICAgICAgICAgc3RhY2tbaWR4XSA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogaWR4LFxuICAgICAgICAgICAgICAgIGRlcHRoOiBoaXN0b3J5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhY3Rpb246IGN1cnJlbnQ/LmFjdGlvbiB8fCBcIlJFUExBQ0VcIixcbiAgICAgICAgICAgICAgICB2aWV3OiB2aWV3LFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoaXN0b3J5U3RhdGUuZW50cmllcyA9IHN0YWNrO1xuXG4gICAgLy8gU2V0IGluaXRpYWwgc3RhdGUgaWYgbmVlZGVkXG4gICAgaWYgKCFjdXJyZW50LnRpbWVzdGFtcCkge1xuICAgICAgICBjb25zdCBzdGF0ZTogSUhpc3RvcnlTdGF0ZSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBpZHgsXG4gICAgICAgICAgICBkZXB0aDogaGlzdG9yeS5sZW5ndGgsXG4gICAgICAgICAgICBhY3Rpb246IFwiUkVQTEFDRVwiLFxuICAgICAgICAgICAgdmlldzogdmlldyxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9O1xuICAgICAgICBoaXN0b3J5Py5yZXBsYWNlU3RhdGU/LihtZXJnZVN0YXRlKHN0YXRlKSwgXCJcIiwgbG9jYXRpb24uaGFzaCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHN0YWNrXG4gICAgICAgIGlmIChoaXN0b3J5U3RhdGU/LmVudHJpZXMpIHtcbiAgICAgICAgICAgIGhpc3RvcnlTdGF0ZS5lbnRyaWVzW2lkeF0gPSBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBzYXZlU3RhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTeW5jIHJlYWN0aXZlIHN0YXRlIHdpdGggZXhpc3RpbmcgaGlzdG9yeSBzdGF0ZVxuICAgICAgICBoaXN0b3J5U3RhdGUuaW5kZXggPSBjdXJyZW50LmluZGV4IHx8IDA7XG4gICAgICAgIGhpc3RvcnlTdGF0ZS52aWV3ID0gY3VycmVudC52aWV3IHx8IHZpZXc7XG5cbiAgICAgICAgLy8gRW5zdXJlIHN0YWNrIG1hdGNoZXMgY3VycmVudFxuICAgICAgICBpZiAoIWhpc3RvcnlTdGF0ZT8uZW50cmllcz8uW2hpc3RvcnlTdGF0ZT8uaW5kZXhdKSB7XG4gICAgICAgICAgICAgaGlzdG9yeVN0YXRlLmVudHJpZXNbaGlzdG9yeVN0YXRlLmluZGV4XSA9IGN1cnJlbnQgYXMgSUhpc3RvcnlTdGF0ZTtcbiAgICAgICAgICAgICBzYXZlU3RhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVJlYWN0aXZlU3RhdGUoZ2V0Q3VycmVudFN0YXRlKCk/LmFjdGlvbiB8fCBcIlJFUExBQ0VcIiwgdmlldyk7XG5cbiAgICAvL1xuICAgIGhpc3RvcnkuZ28gPSAoZGVsdGEgPSAwKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGdldEN1cnJlbnRTdGF0ZSgpO1xuICAgICAgICBjdXJyZW50U3RhdGUuaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihoaXN0b3J5U3RhdGUubGVuZ3RoLCAoY3VycmVudFN0YXRlLmluZGV4IHx8IDApICsgZGVsdGEpKTtcbiAgICAgICAgY29uc3QgZXhpc3RzU3RhdGUgPSBoaXN0b3J5U3RhdGUuZW50cmllc1tjdXJyZW50U3RhdGUuaW5kZXhdO1xuICAgICAgICBPYmplY3QuYXNzaWduKGN1cnJlbnRTdGF0ZSwgZXhpc3RzU3RhdGUgfHwge30pO1xuXG4gICAgICAgIC8vXG4gICAgICAgIHNldElnbm9yZU5leHRQb3BTdGF0ZSh0cnVlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb3JpZ2luYWxHbz8uKGRlbHRhKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHNldElnbm9yZU5leHRQb3BTdGF0ZShmYWxzZSk7IH0sIDApO1xuXG4gICAgICAgIC8vXG4gICAgICAgIHVwZGF0ZVJlYWN0aXZlU3RhdGUoKGN1cnJlbnRTdGF0ZT8uYWN0aW9uIHx8IFwiUE9QXCIpIHx8IChkZWx0YSA+IDAgPyBcIkZPUldBUkRcIiA6IFwiQkFDS1wiKSBhcyBhbnksIGN1cnJlbnRTdGF0ZT8udmlldyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGhpc3RvcnkuYmFjayA9ICgpID0+IHsgcmV0dXJuIGhpc3RvcnkuZ28oLTEpOyB9O1xuICAgIGhpc3RvcnkuZm9yd2FyZCA9ICgpID0+IHsgcmV0dXJuIGhpc3RvcnkuZ28oMSk7IH07XG4gICAgaGlzdG9yeS5wdXNoU3RhdGUgPSAoZGF0YTogYW55LCB1bnVzZWQ6IHN0cmluZywgdXJsPzogc3RyaW5nIHwgVVJMIHwgbnVsbCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBnZXRDdXJyZW50U3RhdGUoKTtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKGN1cnJlbnRTdGF0ZS5pbmRleCB8fCAwKSArIDE7XG5cbiAgICAgICAgY29uc3QgbmV3U3RhdGU6IElIaXN0b3J5U3RhdGUgPSB7XG4gICAgICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgICAgZGVwdGg6IGhpc3RvcnkubGVuZ3RoICsgMSxcbiAgICAgICAgICAgIGFjdGlvbjogXCJQVVNIXCIsXG4gICAgICAgICAgICB2aWV3OiB1cmwgPyBTdHJpbmcodXJsKSA6IChjdXJyZW50U3RhdGUudmlldyB8fCBcIlwiKSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9yaWdpbmFsUHVzaD8uKG1lcmdlU3RhdGUobmV3U3RhdGUsIGRhdGEpLCB1bnVzZWQsIHVybCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHN0YWNrOiB3aXBlIGZvcndhcmQgaGlzdG9yeVxuICAgICAgICBoaXN0b3J5U3RhdGUuZW50cmllcyA9IGhpc3RvcnlTdGF0ZT8uZW50cmllcz8uc2xpY2U/LigwLCBuZXh0SW5kZXgpO1xuICAgICAgICBoaXN0b3J5U3RhdGUuZW50cmllcz8ucHVzaD8uKG5ld1N0YXRlKTtcbiAgICAgICAgc2F2ZVN0YWNrKCk7XG5cbiAgICAgICAgdXBkYXRlUmVhY3RpdmVTdGF0ZShcIlBVU0hcIiwgbmV3U3RhdGUudmlldyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vXG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUgPSAoZGF0YTogYW55LCB1bnVzZWQ6IHN0cmluZywgdXJsPzogc3RyaW5nIHwgVVJMIHwgbnVsbCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBnZXRDdXJyZW50U3RhdGUoKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBjdXJyZW50U3RhdGU/LmluZGV4IHx8IDA7XG5cbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgbmV3U3RhdGU6IElIaXN0b3J5U3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5jdXJyZW50U3RhdGUsXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICBkZXB0aDogaGlzdG9yeS5sZW5ndGgsXG4gICAgICAgICAgICBhY3Rpb246IFwiUkVQTEFDRVwiLFxuICAgICAgICAgICAgdmlldzogdXJsID8gU3RyaW5nKHVybCkgOiAoY3VycmVudFN0YXRlPy52aWV3IHx8IFwiXCIpLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb3JpZ2luYWxSZXBsYWNlPy4obWVyZ2VTdGF0ZShuZXdTdGF0ZSwgZGF0YSksIHVudXNlZCwgdXJsKTtcblxuICAgICAgICAvLyBVcGRhdGUgc3RhY2s6IHJlcGxhY2UgY3VycmVudFxuICAgICAgICBpZiAoaGlzdG9yeVN0YXRlPy5lbnRyaWVzKSB7XG4gICAgICAgICAgICBoaXN0b3J5U3RhdGUuZW50cmllc1tpbmRleF0gPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIGhpc3RvcnlTdGF0ZS5lbnRyaWVzW2hpc3RvcnlTdGF0ZS5pbmRleF0udmlldyA9IHVybCA/IFN0cmluZyh1cmwpIDogKGN1cnJlbnRTdGF0ZT8udmlldyB8fCBcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIHNhdmVTdGFjaygpO1xuICAgICAgICB1cGRhdGVSZWFjdGl2ZVN0YXRlKFwiUkVQTEFDRVwiLCBuZXdTdGF0ZS52aWV3KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gTGlzdGVuIGZvciBwb3BzdGF0ZVxuICAgIGFkZEV2ZW50KHdpbmRvdywgXCJwb3BzdGF0ZVwiLCAoZXYpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBldi5zdGF0ZT8uW1NUQVRFX0tFWV0gYXMgSUhpc3RvcnlTdGF0ZTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gaGlzdG9yeVN0YXRlLmluZGV4ID8/IDA7XG5cbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgLy8gTGlrZWx5IGEgaGFzaCBjaGFuZ2Ugb3IgZXh0ZXJuYWwgbmF2aWdhdGlvblxuICAgICAgICAgICAgLy8gV2UgdHJlYXQgaXQgYXMgYSBQVVNIIGZvciBub3cgaWYgd2UgY2FuJ3QgZGV0ZXJtaW5lIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IGlmIHdlIGhhdmUgZW50cmllcywgd2UgbWlnaHQgY2hlY2sgaWYgaGFzaCBtYXRjaGVzP1xuICAgICAgICAgICAgLy8gRm9yIG5vdywga2VlcCBleGlzdGluZyBsb2dpY1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGU6IElIaXN0b3J5U3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgZGVwdGg6IGhpc3RvcnkubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJQVVNIXCIsXG4gICAgICAgICAgICAgICAgdmlldzogbG9jYXRpb24uaGFzaCB8fCBcIiNcIixcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEluamVjdCBzdGF0ZSBidXQgcHJlc2VydmUgYW55IGV4aXN0aW5nIHN0YXRlIGlmIHByZXNlbnQgKHVubGlrZWx5IGlmIGV2LnN0YXRlIGlzIG51bGwpXG4gICAgICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShtZXJnZVN0YXRlKG5ld1N0YXRlLCBldi5zdGF0ZSksIFwiXCIsIGxvY2F0aW9uLmhhc2gpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgc3RhY2tcbiAgICAgICAgICAgIGhpc3RvcnlTdGF0ZS5lbnRyaWVzID0gaGlzdG9yeVN0YXRlPy5lbnRyaWVzPy5zbGljZT8uKDAsIG5ld1N0YXRlLmluZGV4KTtcbiAgICAgICAgICAgIGhpc3RvcnlTdGF0ZT8uZW50cmllcz8ucHVzaD8uKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIHNhdmVTdGFjaygpO1xuXG4gICAgICAgICAgICB1cGRhdGVSZWFjdGl2ZVN0YXRlKFwiUFVTSFwiLCBuZXdTdGF0ZS52aWV3KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ID0gc3RhdGU/LmluZGV4ID8/IDA7XG4gICAgICAgICAgICBsZXQgYWN0aW9uOiBOYXZpZ2F0aW9uQWN0aW9uID0gXCJQT1BcIjtcbiAgICAgICAgICAgIGlmIChuZXdJbmRleCA8IGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9IFwiQkFDS1wiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdJbmRleCA+IGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9IFwiRk9SV0FSRFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlUmVhY3RpdmVTdGF0ZShhY3Rpb24sIHN0YXRlPy52aWV3IHx8IGxvY2F0aW9uLmhhc2gpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGhhc2hjaGFuZ2UgYXMgZmFsbGJhY2svYXVnbWVudFxuICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBjYXRjaCBjaGFuZ2VzIHRoYXQgbWlnaHQgYnlwYXNzIHBvcHN0YXRlIGluIHNvbWUgc2NlbmFyaW9zXG4gICAgLy8gb3Igd2hlbiBtYW51YWwgbG9jYXRpb24uaGFzaCBhc3NpZ25tZW50IG9jY3VycyB3aXRob3V0IGhpc3RvcnkgQVBJXG4gICAgYWRkRXZlbnQod2luZG93LCBcImhhc2hjaGFuZ2VcIiwgKGV2KSA9PiB7XG4gICAgICAgIGlmIChnZXRJZ25vcmVOZXh0UG9wU3RhdGUoKSkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRIYXNoID0gbG9jYXRpb24uaGFzaCB8fCBcIiNcIjtcbiAgICAgICAgLy8gT25seSB1cGRhdGUgaWYgaGlzdG9yeVN0YXRlIGhhc24ndCBjYXVnaHQgdXAgeWV0IChkZWR1cGxpY2F0aW9uIHdpdGggcG9wc3RhdGUpXG4gICAgICAgIGlmIChoaXN0b3J5U3RhdGUudmlldyAhPT0gY3VycmVudEhhc2gpIHtcblxuICAgICAgICAgICAgLy8gcHJldmVudCBoYXRjaGluZyBwb3BzdGF0ZSBldmVudFxuICAgICAgICAgICAgdXBkYXRlUmVhY3RpdmVTdGF0ZShcIlBVU0hcIiwgY3VycmVudEhhc2gpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vL1xuY29uc3QgdXBkYXRlUmVhY3RpdmVTdGF0ZSA9IChhY3Rpb24/OiBOYXZpZ2F0aW9uQWN0aW9uLCB2aWV3Pzogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IGdldEN1cnJlbnRTdGF0ZSgpO1xuICAgIGhpc3RvcnlTdGF0ZS5pbmRleCA9IGN1cnJlbnQuaW5kZXggfHwgMDtcbiAgICBoaXN0b3J5U3RhdGUubGVuZ3RoID0gaGlzdG9yeS5sZW5ndGg7XG4gICAgaGlzdG9yeVN0YXRlLmFjdGlvbiA9IGFjdGlvbiB8fCBcIlBPUFwiO1xuICAgIGhpc3RvcnlTdGF0ZS52aWV3ID0gdmlldyB8fCBjdXJyZW50LnZpZXcgfHwgbG9jYXRpb24uaGFzaDtcbiAgICBoaXN0b3J5U3RhdGUuY2FuQmFjayA9IGhpc3RvcnlTdGF0ZS5pbmRleCA+IDA7XG59O1xuXG4vLyBOYXZpZ2F0aW9uIGhlbHBlcnNcbmV4cG9ydCBjb25zdCBuYXZpZ2F0ZSA9ICh2aWV3OiBzdHJpbmcsIHJlcGxhY2U6IGJvb2xlYW4gPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGhhc2ggPSB2aWV3LnN0YXJ0c1dpdGgoXCIjXCIpID8gdmlldyA6IGAjJHt2aWV3fWA7XG5cbiAgICAvLyBPcHRpbWl6YXRpb246IGlmIHJlcGxhY2luZywgY2hlY2sgaWYgd2UgYXJlIGp1c3QgZ29pbmcgYmFjayB0byBwcmV2aW91cyB2aWV3XG4gICAgaWYgKHJlcGxhY2UgJiYgaGlzdG9yeVN0YXRlPy5pbmRleCA+IDApIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGhpc3RvcnlTdGF0ZT8uZW50cmllcz8uW2hpc3RvcnlTdGF0ZT8uaW5kZXggLSAxXTtcbiAgICAgICAgaWYgKHByZXYgJiYgcHJldi52aWV3ID09PSBoYXNoKSB7XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGhhdGNoaW5nIHBvcHN0YXRlIGV2ZW50XG4gICAgICAgICAgICBoaXN0b3J5LmJhY2soKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdoZW4gZG9pbmcgbmF2aWdhdGlvbiwgc3RvcCBoYXRjaGluZyBwb3BzdGF0ZSBldmVudFxuICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIHRoZSBjdXJyZW50IHZpZXcgaXMgdGhlIHNhbWUgYXMgdGhlIG5ldyB2aWV3XG4gICAgICAgIGlmIChoaXN0b3J5U3RhdGU/LmVudHJpZXM/LltoaXN0b3J5U3RhdGUuaW5kZXhdPy52aWV3ICE9PSBoYXNoIHx8IGhpc3RvcnlTdGF0ZT8uZW50cmllcz8uW2hpc3RvcnlTdGF0ZS5pbmRleF0/LnZpZXcpIHtcbiAgICAgICAgICAgIGhpc3Rvcnk/LnJlcGxhY2VTdGF0ZT8uKG51bGwsIFwiXCIsIGhhc2gpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaGlzdG9yeT8ucHVzaFN0YXRlPy4obnVsbCwgXCJcIiwgaGFzaCk7XG4gICAgfVxufTtcblxuLy9cbmV4cG9ydCBjb25zdCBoaXN0b3J5Vmlld1JlZiA9IChpbml0aWFsVmFsdWU6IHN0cmluZyA9IGAjJHtsb2NhdGlvbi5oYXNoPy5yZXBsYWNlPy4oL14jLywgXCJcIikgfHwgXCJob21lXCJ9YCwgb3B0aW9uczogeyBpZ25vcmVCYWNrPzogYm9vbGVhbiwgd2l0aG91dEhhc2hQcmVmaXg/OiBib29sZWFuIH0gPSB7fSkgPT4ge1xuICAgIGNvbnN0IGludGVybmFsID0gb2JzZXJ2ZSh7IHZhbHVlOiBpbml0aWFsVmFsdWUgfSkgYXMgdW5rbm93biBhcyB7IHZhbHVlOiBzdHJpbmcgfTtcblxuICAgIC8vIFByZXZlbnQgY2lyY3VsYXIgdXBkYXRlcyBiZXR3ZWVuIGhpc3RvcnkgYW5kIGludGVybmFsIHZhbHVlXG4gICAgbGV0IGlzVXBkYXRpbmdGcm9tSGlzdG9yeSA9IGZhbHNlO1xuICAgIGxldCBpc1VwZGF0aW5nRnJvbUludGVybmFsID0gZmFsc2U7XG5cbiAgICAvLyBTeW5jIGZyb20gaGlzdG9yeSB0byByZWZcbiAgICAvLyBUaGUgaGlzdG9yeVN0YXRlIGFjdHMgYXMgYSBicmlkZ2U6XG4gICAgLy8gMS4gVXNlciBBY3Rpb24gKEJhY2svRm9yd2FyZCkgLT4gV2luZG93ICdwb3BzdGF0ZScgLT4gaW5pdEhpc3RvcnkgbGlzdGVuZXIgLT4gaGlzdG9yeVN0YXRlIC0+IFRoaXMgU3Vic2NyaXB0aW9uXG4gICAgLy8gMi4gVXNlciBBY3Rpb24gKEhhc2ggQ2hhbmdlKSAtPiBXaW5kb3cgJ2hhc2hjaGFuZ2UnIC0+IGluaXRIaXN0b3J5IGxpc3RlbmVyIC0+IGhpc3RvcnlTdGF0ZSAtPiBUaGlzIFN1YnNjcmlwdGlvblxuICAgIGFmZmVjdGVkKFtoaXN0b3J5U3RhdGUsIFwidmlld1wiXSwgKHZpZXc6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoaXNVcGRhdGluZ0Zyb21JbnRlcm5hbCkgcmV0dXJuOyAvLyBQcmV2ZW50IGNpcmN1bGFyIHVwZGF0ZVxuXG4gICAgICAgIGlmIChvcHRpb25zLmlnbm9yZUJhY2sgJiYgaGlzdG9yeVN0YXRlLmFjdGlvbiA9PT0gXCJCQUNLXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuZXh0VmFsdWUgPSB2aWV3O1xuICAgICAgICBpZiAob3B0aW9ucy53aXRob3V0SGFzaFByZWZpeCkge1xuICAgICAgICAgICAgbmV4dFZhbHVlID0gdmlldy5yZXBsYWNlKC9eIy8sIFwiXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludGVybmFsLnZhbHVlICE9PSBuZXh0VmFsdWUpIHtcbiAgICAgICAgICAgIGlzVXBkYXRpbmdGcm9tSGlzdG9yeSA9IHRydWU7XG4gICAgICAgICAgICBpbnRlcm5hbC52YWx1ZSA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIGlzVXBkYXRpbmdGcm9tSGlzdG9yeSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTeW5jIGZyb20gcmVmIHRvIGhpc3RvcnlcbiAgICAvLyBBcHBsaWNhdGlvbiBBY3Rpb24gKFByb2dyYW1tYXRpYykgLT4gcmVmLnZhbHVlIGNoYW5nZSAtPiBUaGlzIFN1YnNjcmlwdGlvbiAtPiBuYXZpZ2F0ZSgpIC0+IHB1c2hTdGF0ZSgpIC0+IGhpc3RvcnlTdGF0ZVxuICAgIGFmZmVjdGVkKFtpbnRlcm5hbCwgXCJ2YWx1ZVwiXSwgKHZhbDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChpc1VwZGF0aW5nRnJvbUhpc3RvcnkpIHJldHVybjsgLy8gUHJldmVudCBjaXJjdWxhciB1cGRhdGVcblxuICAgICAgICBsZXQgdmlld1RvTmF2aWdhdGUgPSB2YWw7XG4gICAgICAgIGlmIChvcHRpb25zLndpdGhvdXRIYXNoUHJlZml4ICYmICF2YWwuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgICAgICAgIHZpZXdUb05hdmlnYXRlID0gYCMke3ZhbH1gO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhpc3RvcnlTdGF0ZS52aWV3ICE9PSB2aWV3VG9OYXZpZ2F0ZSkge1xuICAgICAgICAgICAgaXNVcGRhdGluZ0Zyb21JbnRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgcHJvZ3JhbW1hdGljIGNoYW5nZSwgc28gd2UgUFVTSFxuICAgICAgICAgICAgbmF2aWdhdGUodmlld1RvTmF2aWdhdGUpO1xuICAgICAgICAgICAgaXNVcGRhdGluZ0Zyb21JbnRlcm5hbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBQcm94eSB0byByZXR1cm4gdGhlIHJlZiBidXQgd2l0aCBzcGVjaWFsIGJlaGF2aW9yIGlmIG5lZWRlZFxuICAgIHJldHVybiBpbnRlcm5hbDtcbn07XG4iXX0=